<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>arsenalgear-cpp: agr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">arsenalgear-cpp
   </div>
   <div id="projectbrief">A library containing general purpose C++ utils.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">agr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagr_1_1savebuf.html">savebuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to store the output sent to an output stream.  <a href="classagr_1_1savebuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagr_1_1select__cout.html">select_cout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used to define a way to template the choice of the "std::cout" object in order to be "std::cout" for "char" type or "std::wcout" for "wchar_t" type.  <a href="structagr_1_1select__cout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagr_1_1select__cin.html">select_cin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used to define a way to template the choice of the "std::cin" object in order to be "std::cin" for "char" type or "std::wcin" for "wchar_t" type.  <a href="structagr_1_1select__cin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagr_1_1is__streamable.html">is_streamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used to check if a type is a streamable or not, i.e. it has operator &lt;&lt; overload or not.  <a href="structagr_1_1is__streamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagr_1_1is__streamable_3_01S_00_01T_00_01std_1_1void__t_3_01decltype_07std_1_1declval_3_01S07be0fae6b13f93697c0fcdbe88a7bf8.html">is_streamable&lt; S, T, std::void_t&lt; decltype(std::declval&lt; S &amp; &gt;()&lt;&lt; std::declval&lt; T &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aec178c3f78cfa7e5fd1e438661ad7b7e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceagr.html#aec178c3f78cfa7e5fd1e438661ad7b7e">ANSI</a> { <a class="el" href="namespaceagr.html#aec178c3f78cfa7e5fd1e438661ad7b7ea8b04d5e3775d298e78455efc5ca404d5">first</a>
, <a class="el" href="namespaceagr.html#aec178c3f78cfa7e5fd1e438661ad7b7ea3d517f8924ac7fd03699a29d97dc52d9">generic</a>
 }</td></tr>
<tr class="separator:aec178c3f78cfa7e5fd1e438661ad7b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1941ebf177b4bdb1d7f322ed3daed0bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a1941ebf177b4bdb1d7f322ed3daed0bc">getCommandOut</a> (const char *command)</td></tr>
<tr class="memdesc:a1941ebf177b4bdb1d7f322ed3daed0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to get the output of a shell command.  <a href="namespaceagr.html#a1941ebf177b4bdb1d7f322ed3daed0bc">More...</a><br /></td></tr>
<tr class="separator:a1941ebf177b4bdb1d7f322ed3daed0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562d67b1ade6b34802403c2736125959"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a562d67b1ade6b34802403c2736125959">multi</a> (const std::string &amp;element, uint32_t n_times)</td></tr>
<tr class="memdesc:a562d67b1ade6b34802403c2736125959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to multiply a string for n times.  <a href="namespaceagr.html#a562d67b1ade6b34802403c2736125959">More...</a><br /></td></tr>
<tr class="separator:a562d67b1ade6b34802403c2736125959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccaa1589b9a22ee3ad2bc2ac798dbcd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceagr.html#aeccaa1589b9a22ee3ad2bc2ac798dbcd">split_string</a> (const std::string &amp;input, const std::string &amp;regex)</td></tr>
<tr class="memdesc:aeccaa1589b9a22ee3ad2bc2ac798dbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to split a string based on a certain reges.  <a href="namespaceagr.html#aeccaa1589b9a22ee3ad2bc2ac798dbcd">More...</a><br /></td></tr>
<tr class="separator:aeccaa1589b9a22ee3ad2bc2ac798dbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe08b78ae648a1b2401c7559de314989"><td class="memTemplParams" colspan="2">template&lt;typename TK , typename TV &gt; </td></tr>
<tr class="memitem:abe08b78ae648a1b2401c7559de314989"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TK &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#abe08b78ae648a1b2401c7559de314989">extract_map_keys</a> (std::map&lt; TK, TV &gt; const &amp;input_map)</td></tr>
<tr class="memdesc:abe08b78ae648a1b2401c7559de314989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to extract a vector of keys from a map.  <a href="namespaceagr.html#abe08b78ae648a1b2401c7559de314989">More...</a><br /></td></tr>
<tr class="separator:abe08b78ae648a1b2401c7559de314989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70373a18f780e358537a4c57b8ab81aa"><td class="memTemplParams" colspan="2">template&lt;typename TK , typename TV &gt; </td></tr>
<tr class="memitem:a70373a18f780e358537a4c57b8ab81aa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TV &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a70373a18f780e358537a4c57b8ab81aa">extract_map_elem</a> (std::map&lt; TK, TV &gt; const &amp;input_map)</td></tr>
<tr class="memdesc:a70373a18f780e358537a4c57b8ab81aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to extract a vector of elements from a map.  <a href="namespaceagr.html#a70373a18f780e358537a4c57b8ab81aa">More...</a><br /></td></tr>
<tr class="separator:a70373a18f780e358537a4c57b8ab81aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b5429193e1316a42ca73e8123a8bd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29b5429193e1316a42ca73e8123a8bd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a29b5429193e1316a42ca73e8123a8bd5">roundoff</a> (T value, unsigned char prec)</td></tr>
<tr class="memdesc:a29b5429193e1316a42ca73e8123a8bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to round a floating point to n-th decimal place after comma.  <a href="namespaceagr.html#a29b5429193e1316a42ca73e8123a8bd5">More...</a><br /></td></tr>
<tr class="separator:a29b5429193e1316a42ca73e8123a8bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631f02dbbfad7ff146ef86e89d2ddb4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a631f02dbbfad7ff146ef86e89d2ddb4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a631f02dbbfad7ff146ef86e89d2ddb4c">IsInBounds</a> (T value, T low, T high)</td></tr>
<tr class="memdesc:a631f02dbbfad7ff146ef86e89d2ddb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if a number lies in a certain bound or not.  <a href="namespaceagr.html#a631f02dbbfad7ff146ef86e89d2ddb4c">More...</a><br /></td></tr>
<tr class="separator:a631f02dbbfad7ff146ef86e89d2ddb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5ec6c4708748caba50bd7444a8707a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a7c5ec6c4708748caba50bd7444a8707a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a7c5ec6c4708748caba50bd7444a8707a">is_pointer_to_const_char</a> (T(&amp;)[N])</td></tr>
<tr class="memdesc:a7c5ec6c4708748caba50bd7444a8707a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to check if an input array is a pointer to const char.  <a href="namespaceagr.html#a7c5ec6c4708748caba50bd7444a8707a">More...</a><br /></td></tr>
<tr class="separator:a7c5ec6c4708748caba50bd7444a8707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967afc81c623b378f2bf66e6d5d0956b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a967afc81c623b378f2bf66e6d5d0956b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a967afc81c623b378f2bf66e6d5d0956b">is_pointer_to_const_char</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:a967afc81c623b378f2bf66e6d5d0956b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to check if an input variable is a pointer to const char.  <a href="namespaceagr.html#a967afc81c623b378f2bf66e6d5d0956b">More...</a><br /></td></tr>
<tr class="separator:a967afc81c623b378f2bf66e6d5d0956b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cedbda93e6317c38b992056458ba03c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8cedbda93e6317c38b992056458ba03c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a8cedbda93e6317c38b992056458ba03c">is_str</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a8cedbda93e6317c38b992056458ba03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to check if a variable is a string object (std::string, const char*, etc...).  <a href="namespaceagr.html#a8cedbda93e6317c38b992056458ba03c">More...</a><br /></td></tr>
<tr class="separator:a8cedbda93e6317c38b992056458ba03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962b9e5500ec34ba186b3ad88114a677"><td class="memTemplParams" colspan="2">template&lt;typename Kind , typename... Kinds&gt; </td></tr>
<tr class="memitem:a962b9e5500ec34ba186b3ad88114a677"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a962b9e5500ec34ba186b3ad88114a677">is_any</a> ()</td></tr>
<tr class="memdesc:a962b9e5500ec34ba186b3ad88114a677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to check if a type is in a list or not.  <a href="namespaceagr.html#a962b9e5500ec34ba186b3ad88114a677">More...</a><br /></td></tr>
<tr class="separator:a962b9e5500ec34ba186b3ad88114a677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bb5e1fbefa30c3e0f6e24a80d463b8"><td class="memTemplParams" colspan="2">template&lt;typename T_err  = std::runtime_error&gt; </td></tr>
<tr class="memitem:a60bb5e1fbefa30c3e0f6e24a80d463b8"><td class="memTemplItemLeft" align="right" valign="top">T_err&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a60bb5e1fbefa30c3e0f6e24a80d463b8">except_error_func</a> (const std::string &amp;beg=&quot;&quot;, std::string var=nullptr, const std::string &amp;end=&quot;&quot;)</td></tr>
<tr class="memdesc:a60bb5e1fbefa30c3e0f6e24a80d463b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to throw customized stdexception error. This function is extremely specific to my purposes and you can find examples usages in other my projects lik "osmanip" or "SAFD-algorithm".  <a href="namespaceagr.html#a60bb5e1fbefa30c3e0f6e24a80d463b8">More...</a><br /></td></tr>
<tr class="separator:a60bb5e1fbefa30c3e0f6e24a80d463b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f754b298e55c68819829df78d936cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30f754b298e55c68819829df78d936cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a30f754b298e55c68819829df78d936cb">isFloatingPoint</a> (const T &amp;)</td></tr>
<tr class="memdesc:a30f754b298e55c68819829df78d936cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if an expression (not a type) is a floating point or not. I know this function is almost useless, but it has been created for lazy purposes and since it is used in other projects it cannot be eliminated now in order to not break backward compatibility.  <a href="namespaceagr.html#a30f754b298e55c68819829df78d936cb">More...</a><br /></td></tr>
<tr class="separator:a30f754b298e55c68819829df78d936cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c1d16a030bfa822fcf06fcfd56db5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79c1d16a030bfa822fcf06fcfd56db5a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a79c1d16a030bfa822fcf06fcfd56db5a">one</a> (const T &amp;iterating_var)</td></tr>
<tr class="memdesc:a79c1d16a030bfa822fcf06fcfd56db5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the incremented unit of a loop. Not easy to understand its purpose without context, but it is used to get the loop incremented unit in case of loops with floating-point indexes. See example usage in "osmanip" in progress bars "update" method.  <a href="namespaceagr.html#a79c1d16a030bfa822fcf06fcfd56db5a">More...</a><br /></td></tr>
<tr class="separator:a79c1d16a030bfa822fcf06fcfd56db5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3019dd5d7deec3df2a2c4e01b89f47"><td class="memTemplParams" colspan="2">template&lt;class CharT &gt; </td></tr>
<tr class="memitem:a1d3019dd5d7deec3df2a2c4e01b89f47"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; std::is_same_v&lt; CharT, char &gt;, const std::basic_string&lt; CharT &gt; &amp;, std::basic_string&lt; CharT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a1d3019dd5d7deec3df2a2c4e01b89f47">StringConverter</a> (const std::string &amp;input_str)</td></tr>
<tr class="memdesc:a1d3019dd5d7deec3df2a2c4e01b89f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to convert an std::string into other string types (std::wstring etc...). If the argument is an std::string it will be returned without any modification.  <a href="namespaceagr.html#a1d3019dd5d7deec3df2a2c4e01b89f47">More...</a><br /></td></tr>
<tr class="separator:a1d3019dd5d7deec3df2a2c4e01b89f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9108a0675bd694e9a9eaf2fd577d96"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d9108a0675bd694e9a9eaf2fd577d96"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a9d9108a0675bd694e9a9eaf2fd577d96">is_escape</a> (const T &amp;str, const <a class="el" href="namespaceagr.html#aec178c3f78cfa7e5fd1e438661ad7b7e">ANSI</a> &amp;flag)</td></tr>
<tr class="memdesc:a9d9108a0675bd694e9a9eaf2fd577d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to check if an input variable is an ANSI escape sequency or not.  <a href="namespaceagr.html#a9d9108a0675bd694e9a9eaf2fd577d96">More...</a><br /></td></tr>
<tr class="separator:a9d9108a0675bd694e9a9eaf2fd577d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1d792d292bac3e11731eb31cac8dd46e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d792d292bac3e11731eb31cac8dd46e"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#a1d792d292bac3e11731eb31cac8dd46e">null_str</a> { &quot;&quot; }</td></tr>
<tr class="memdesc:a1d792d292bac3e11731eb31cac8dd46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string used to represent the null value.  <a href="namespaceagr.html#a1d792d292bac3e11731eb31cac8dd46e">More...</a><br /></td></tr>
<tr class="separator:a1d792d292bac3e11731eb31cac8dd46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68907b37ef6e4abe00f6cf74778cde0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af68907b37ef6e4abe00f6cf74778cde0"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceagr.html#af68907b37ef6e4abe00f6cf74778cde0">empty_space</a> { &quot; &quot; }</td></tr>
<tr class="memdesc:af68907b37ef6e4abe00f6cf74778cde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string used to represent the empty space.  <a href="namespaceagr.html#af68907b37ef6e4abe00f6cf74778cde0">More...</a><br /></td></tr>
<tr class="separator:af68907b37ef6e4abe00f6cf74778cde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aec178c3f78cfa7e5fd1e438661ad7b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec178c3f78cfa7e5fd1e438661ad7b7e">&#9670;&nbsp;</a></span>ANSI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceagr.html#aec178c3f78cfa7e5fd1e438661ad7b7e">agr::ANSI</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aec178c3f78cfa7e5fd1e438661ad7b7ea8b04d5e3775d298e78455efc5ca404d5"></a>first&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aec178c3f78cfa7e5fd1e438661ad7b7ea3d517f8924ac7fd03699a29d97dc52d9"></a>generic&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a60bb5e1fbefa30c3e0f6e24a80d463b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bb5e1fbefa30c3e0f6e24a80d463b8">&#9670;&nbsp;</a></span>except_error_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_err  = std::runtime_error&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_err agr::except_error_func </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>beg</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>var</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function used to throw customized stdexception error. This function is extremely specific to my purposes and you can find examples usages in other my projects lik "osmanip" or "SAFD-algorithm". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_err</td><td>The type of the exception error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>The first part of the error message. </td></tr>
    <tr><td class="paramname">var</td><td>The variable to be inserted in the error message. </td></tr>
    <tr><td class="paramname">end</td><td>The last part of the error message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T_err The modified exception error. </dd></dl>

</div>
</div>
<a id="a70373a18f780e358537a4c57b8ab81aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70373a18f780e358537a4c57b8ab81aa">&#9670;&nbsp;</a></span>extract_map_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK , typename TV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;TV&gt; agr::extract_map_elem </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; TK, TV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function used to extract a vector of elements from a map. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TK</td><td>Template parameter of the map key. </td></tr>
    <tr><td class="paramname">TV</td><td>Template parameter of the map element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_map</td><td>The input map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;TV&gt; The vector of elements. </dd></dl>

</div>
</div>
<a id="abe08b78ae648a1b2401c7559de314989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe08b78ae648a1b2401c7559de314989">&#9670;&nbsp;</a></span>extract_map_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK , typename TV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;TK&gt; agr::extract_map_keys </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; TK, TV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function used to extract a vector of keys from a map. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TK</td><td>Template parameter of the map key. </td></tr>
    <tr><td class="paramname">TV</td><td>Template parameter of the map element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_map</td><td>The input map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;TK&gt; The vector of keys. </dd></dl>

</div>
</div>
<a id="a1941ebf177b4bdb1d7f322ed3daed0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1941ebf177b4bdb1d7f322ed3daed0bc">&#9670;&nbsp;</a></span>getCommandOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string agr::getCommandOut </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function used to get the output of a shell command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command which output is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The output of the command variable. </dd></dl>

</div>
</div>
<a id="a962b9e5500ec34ba186b3ad88114a677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962b9e5500ec34ba186b3ad88114a677">&#9670;&nbsp;</a></span>is_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , typename... Kinds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool agr::is_any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function used to check if a type is in a list or not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Kind</td><td>The type to be checked. </td></tr>
    <tr><td class="paramname">Kinds</td><td>The types to which the type is compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the type is in a list. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="a9d9108a0675bd694e9a9eaf2fd577d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9108a0675bd694e9a9eaf2fd577d96">&#9670;&nbsp;</a></span>is_escape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool agr::is_escape </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceagr.html#aec178c3f78cfa7e5fd1e438661ad7b7e">ANSI</a> &amp;&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is used to check if an input variable is an ANSI escape sequency or not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Template type of the input variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input variable. </td></tr>
    <tr><td class="paramname">flag</td><td>A flag which let to return different things with respect to its value. If flag = <a class="el" href="namespaceagr.html#aec178c3f78cfa7e5fd1e438661ad7b7ea8b04d5e3775d298e78455efc5ca404d5">ANSI::first</a> the ANSI is searched as the first substring of the str argument, otherwise, if flag = <a class="el" href="namespaceagr.html#aec178c3f78cfa7e5fd1e438661ad7b7ea3d517f8924ac7fd03699a29d97dc52d9">ANSI::generic</a> the ANSI is searched as a substring inside the str argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the input variable is an ANSI escape sequency. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="a967afc81c623b378f2bf66e6d5d0956b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967afc81c623b378f2bf66e6d5d0956b">&#9670;&nbsp;</a></span>is_pointer_to_const_char() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool agr::is_pointer_to_const_char </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function used to check if an input variable is a pointer to const char. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input variable to be check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the variable is a pointer to const char. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="a7c5ec6c4708748caba50bd7444a8707a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5ec6c4708748caba50bd7444a8707a">&#9670;&nbsp;</a></span>is_pointer_to_const_char() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool agr::is_pointer_to_const_char </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function used to check if an input array is a pointer to const char. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input array to be check. </td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the array is a pointer to const char. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="a8cedbda93e6317c38b992056458ba03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cedbda93e6317c38b992056458ba03c">&#9670;&nbsp;</a></span>is_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool agr::is_str </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function used to check if a variable is a string object (std::string, const char*, etc...). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The input variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the variable is a string object. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="a30f754b298e55c68819829df78d936cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f754b298e55c68819829df78d936cb">&#9670;&nbsp;</a></span>isFloatingPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool agr::isFloatingPoint </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to check if an expression (not a type) is a floating point or not. I know this function is almost useless, but it has been created for lazy purposes and since it is used in other projects it cannot be eliminated now in order to not break backward compatibility. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the expression is a floating point, false otherwise. </dd></dl>

</div>
</div>
<a id="a631f02dbbfad7ff146ef86e89d2ddb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631f02dbbfad7ff146ef86e89d2ddb4c">&#9670;&nbsp;</a></span>IsInBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool agr::IsInBounds </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to check if a number lies in a certain bound or not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The Type of the variable to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The variable to be checked. </td></tr>
    <tr><td class="paramname">low</td><td>The lower bound. </td></tr>
    <tr><td class="paramname">high</td><td>The upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the variable lies in the bound, false otherwise. </dd></dl>

</div>
</div>
<a id="a562d67b1ade6b34802403c2736125959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562d67b1ade6b34802403c2736125959">&#9670;&nbsp;</a></span>multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string agr::multi </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_times</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function used to multiply a string for n times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The string to be multiplied. </td></tr>
    <tr><td class="paramname">n_times</td><td>The times for the string multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The multiplied string. </dd></dl>

</div>
</div>
<a id="a79c1d16a030bfa822fcf06fcfd56db5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c1d16a030bfa822fcf06fcfd56db5a">&#9670;&nbsp;</a></span>one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T agr::one </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>iterating_var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to find the incremented unit of a loop. Not easy to understand its purpose without context, but it is used to get the loop incremented unit in case of loops with floating-point indexes. See example usage in "osmanip" in progress bars "update" method. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the iterating variable of the loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterating_var</td><td>The iterating variable of the loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The incremented unit of the loop. </dd></dl>

</div>
</div>
<a id="a29b5429193e1316a42ca73e8123a8bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b5429193e1316a42ca73e8123a8bd5">&#9670;&nbsp;</a></span>roundoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T agr::roundoff </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to round a floating point to n-th decimal place after comma. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The Type of the variable to be rounded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The variable to be rounded </td></tr>
    <tr><td class="paramname">prec</td><td>Precision of the rounding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The rounded variable. </dd></dl>

</div>
</div>
<a id="aeccaa1589b9a22ee3ad2bc2ac798dbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccaa1589b9a22ee3ad2bc2ac798dbcd">&#9670;&nbsp;</a></span>split_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; agr::split_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>regex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function used to split a string based on a certain reges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input string. </td></tr>
    <tr><td class="paramname">regex</td><td>The regex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; The collection of string elements splitted by the regex. </dd></dl>

</div>
</div>
<a id="a1d3019dd5d7deec3df2a2c4e01b89f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3019dd5d7deec3df2a2c4e01b89f47">&#9670;&nbsp;</a></span>StringConverter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt;std::is_same_v&lt;CharT, char&gt;, const std::basic_string&lt;CharT&gt;&amp;, std::basic_string&lt;CharT&gt; &gt; agr::StringConverter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function used to convert an std::string into other string types (std::wstring etc...). If the argument is an std::string it will be returned without any modification. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>The char type (char, wchar_t...) to which the string is converted.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_str</td><td>The input std::string object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::conditional_t&lt;std::is_same_v&lt;CharT, char&gt;, const std::basic_string&lt;CharT&gt;&amp;, std::basic_string&lt;CharT&gt;&gt; The converted string object. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af68907b37ef6e4abe00f6cf74778cde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68907b37ef6e4abe00f6cf74778cde0">&#9670;&nbsp;</a></span>empty_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T agr::empty_space { &quot; &quot; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The string used to represent the empty space. </p>

</div>
</div>
<a id="a1d792d292bac3e11731eb31cac8dd46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d792d292bac3e11731eb31cac8dd46e">&#9670;&nbsp;</a></span>null_str</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T agr::null_str { &quot;&quot; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The string used to represent the null value. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
